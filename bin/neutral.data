#!/bin/bash
#
# Usage: neutral.data [options...] [action]
#
# Options:
#  -h --help ------------- print this help message
#  -i --include CAT=STR -- only include items with CAT=STR in results
#  -e --exclude CAT=STR -- exclude items with CAT=STR from results
#  -b --by [CAT,...] ----- group results by CATs (comma separated)
#  -g --graph ------------ graph mean of results (requires feedgnuplot)
#  -o --output FILE ------ save output to FILE
#
# Actions (specify at most one to reduce results):
#  -m --mean ------------- mean of all matching results
#  -s --sum -------------- mean of all matching results
#
# Categories (CAT):
#  One of algorithm, language, compiler, flag.  Substrings may be
#  used, e.g., "a" for "algorithm".
#
# Examples:
#
#   to print a table of the mean neutrality by algorithm and language,
#   use:
#
#     neutral.data -b lang,alg -m
#   
#   to calculate the mean neutrality by compiler, and graph the
#   results to an svg file, use:
#   
#     neutral.data -b comp -m -g -o /tmp/by-lang.svg
#     
#
error(){ echo "$0: $@" >&2; exit 1; }
ACT="all"
OUT=""
GRAPH=""
declare -a INC
declare -a EXC
declare -a CAT
row(){ # match categories to rows in the data
    case $1 in
        a*) echo 1;; l*) echo 2;; c*) echo 3;; f*) echo 4;;
        *) error "Category '$i' does not match any category.";;
    esac; }
add_cat(){
    local cat="$1";
    local length=${#CAT[@]};
    if [ $length -gt 1 ];then error "Can specify at most two categories.";
                         else CAT[$length]=$cat; fi; }
add_act(){
    local act="$1";
    if [ ! "$ACT" == "all" ];then error "Can specify at most one action.";
                             else ACT=$act; fi; }
add_inc_exp(){
    local type=$1;
    local pair="$2";
    local cat="$(row $(echo "$pair"|sed 's/=.*$//'))"
    local it="$(echo "$pair"|sed 's/^.*=//')"
    case $type in
        "INC") INC+=($cat); INC+=($it);;
        "EXC") EXC+=($cat); EXC+=($it);;
        *) error "Impossible type $type.";;
    esac; }
RES=5
DATA="$(cat "$0"|sed -n '/^DATA:/,$p'|tail --lines=+2)"

HELP_TEXT=$(cat "$0" \
        |sed '/^[^#]/q' \
        |head -n -1 \
        |tail -n +3 \
        |sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' \
        |cut -c3-)

eval set -- $(getopt \
    -o hi:e:b:msgo: \
    -l help,include:,exclude:,by:,mean,sum,graph,output: \
    -- $@ || echo "$HELP_TEXT" && exit 1;)

while [ $# -gt 0 ];do
    case $1 in
        -h|--help)      echo "$HELP_TEXT" && exit 1;;
        -i|--include)   add_inc_exp "INC" "$2"; shift;;
        -e|--exclude)   add_inc_exp "EXC" "$2"; shift;;
        -b|--by)
            SAVE="$IFS"
            IFS=","
            for i in $2;do
                row $i >/dev/null || exit 1
                add_cat $(row $i)
            done
            shift;
            IFS="$SAVE";;
        -m|--mean)      add_act "mean";;
        -s|--sum)       add_act "sum";;
        -g|--graph)     GRAPH="yes";;
        -o|--output)    OUT="$2"; shift;;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done

# Functions
inc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat == \"$match\") print \$0; }"; }

exc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat != \"$match\") print \$0; }"; }

res(){ awk "{ print \$$RES; }"; }

act(){
    case $ACT in
        all)  tr '\n' ','|sed 's/.$//';;
        sum)  awk '{ sum += $1 }
                   END { if(NR == 0) print "NA"; else print sum; }';;
        mean) awk '{ sum += $1 }
                   END { if(NR == 0) print "NA"; else print sum/NR; }';;
    esac; }

post_process(){
    if [ ! -z "$GRAPH" ];then
        if [ $(which feedgnuplot >/dev/null 2>/dev/null) ];then
            error "Graphing requires the feedgnuplot executable."
        elif [ "$ACT" == "all" ];then
            error "Can't graph all results, must use mean or sum."
        elif [ ${#CAT[@]} -ne 1 ];then
            error "Can only graph a single category at a time."
        else
            if [ ! -z "$OUT" ];then OUT=" --hardcopy $OUT "; fi
            feedgnuplot $OUT \
                -ymin 0 \
                --extracmds 'set style fill solid border -1;' \
                --histogram 2 \
                --curvestyleall 'with boxes' \
                --dataid \
                --autolegen
        fi
    else
        if [ ! -z "$OUT" ];then
            cat >$OUT
            echo "Wrote output to $OUT"
        else
            column -t
        fi
    fi; }

# Main
for ((i=0; i<${#INC[@]}; i+=2));do
    DATA="$(echo "$DATA"|inc ${INC[i]} ${INC[i+1]})"
done
for ((i=0; i<${#EXC[@]}; i+=2));do
    DATA="$(echo "$DATA"|exc ${EXC[i]} ${EXC[i+1]})"
done

case ${#CAT[@]} in
    0) echo "$DATA";;
    1)
        for i in $(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u);do
            echo "$i $(echo "$DATA"|inc ${CAT[0]} $i|res|act)"
        done;;
    2)
        XS="$(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u)"
        YS="$(echo "$DATA"|awk "{print \$${CAT[1]}}"|sort -u)"
        echo "[$(echo "$XS"|wc -l)x$(echo "$YS"|wc -l)] $(echo $YS)"
        for x in $XS;do
            echo -n "$x "
            for y in $YS;do
                echo -n "$(echo "$DATA"|inc ${CAT[0]} $x|inc ${CAT[1]} $y|res|act) "
            done
            echo ""
        done;;
esac|post_process
exit 0;


# The rest of the file should be raw data.
DATA:
bubble cpp g++ O0 395
bubble cpp g++ O2 412
bubble cpp g++ O3 394
bubble cpp g++ Ofast 411
bubble cpp g++ Os 394
insertion c clang O0 393
insertion c clang O1 469
insertion c clang O2 567
insertion c clang O3 506
insertion c clang Os 433
insertion c clang Oz 454
insertion c gcc O0 307
insertion c gcc O1 337
insertion c gcc O2 338
insertion c gcc O3 356
insertion c gcc Ofast 337
insertion c gcc Os 342
insertion cpp g++ O0 524
insertion cpp g++ O1 444
insertion cpp g++ O2 496
insertion cpp g++ O3 573
insertion cpp g++ Ofast 542
insertion cpp g++ Os 472
merge c clang O0 336
merge c clang O1 432
merge c clang O2 500
merge c clang O3 510
merge c clang Os 388
merge c clang Oz 379
merge c gcc O0 299
merge c gcc O1 317
merge c gcc O2 330
merge c gcc O3 345
merge c gcc Ofast 312
merge c gcc Os 309
merge cpp g++ O0 592
merge cpp g++ O1 658
merge cpp g++ O2 721
merge cpp g++ O3 697
merge cpp g++ Ofast 662
merge cpp g++ Os 628
quick c clang O0 402
quick c clang O1 464
quick c clang O2 457
quick c clang O3 475
quick c clang Os 458
quick c clang Oz 430
quick c gcc O0 341
quick c gcc O1 317
quick c gcc O2 347
quick c gcc O3 376
quick c gcc Ofast 379
quick c gcc Os 299
quick cpp g++ O0 468
quick cpp g++ O1 417
quick cpp g++ O2 407
quick cpp g++ O3 455
quick cpp g++ Ofast 469
quick cpp g++ Os 413
