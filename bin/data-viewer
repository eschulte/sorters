#!/bin/bash
#
# Usage: neutral.data [options...] [action]
#
# Options:
#  -h --help ------------- print this help message
#  -i --include CAT=STR -- only include items with CAT=STR in results
#  -e --exclude CAT=STR -- exclude items with CAT=STR from results
#  -b --by [CAT,...] ----- group results by CATs (comma separated)
#  -g --graph ------------ graph mean of results (requires feedgnuplot)
#  -o --output FILE ------ save output to FILE
#
# Actions (specify at most one to reduce results):
#  -m --mean ------------- mean of all matching results
#  -s --sum -------------- mean of all matching results
#
# Categories (CAT):
#  One of algorithm, language, compiler, flag.  Substrings may be
#  used, e.g., "a" for "algorithm".
#
# Examples:
#
#   to print a table of the mean neutrality by algorithm and language,
#   use:
#
#     neutral.data -b lang,alg -m
#   
#   to calculate the mean neutrality by compiler, and graph the
#   results to an svg file, use:
#   
#     neutral.data -b comp -m -g -o /tmp/by-lang.svg
#     
#
error(){ echo "$0: $@" >&2; exit 1; }
TITLE="$0 $@"
ACT="all"
OUT=""
GRAPH=""
declare -a INC
declare -a EXC
declare -a CAT
row(){ # match categories to rows in the data
    case $1 in
        a*) echo 1;; l*) echo 2;; c*) echo 3;; f*) echo 4;;
        *) error "Category '$i' does not match any category.";;
    esac; }
add_cat(){
    local cat="$1";
    local length=${#CAT[@]};
    if [ $length -gt 1 ];then error "Can specify at most two categories.";
                         else CAT[$length]=$cat; fi; }
add_act(){
    local act="$1";
    if [ ! "$ACT" == "all" ];then error "Can specify at most one action.";
                             else ACT=$act; fi; }
add_inc_exp(){
    local type=$1;
    local pair="$2";
    local cat="$(row $(echo "$pair"|sed 's/=.*$//'))"
    local it="$(echo "$pair"|sed 's/^.*=//')"
    case $type in
        "INC") INC+=($cat); INC+=($it);;
        "EXC") EXC+=($cat); EXC+=($it);;
        *) error "Impossible type $type.";;
    esac; }
RES=5
DATA="$(cat "$0"|sed -n '/^DATA:/,$p'|tail --lines=+2)"

HELP_TEXT=$(cat "$0" \
        |sed '/^[^#]/q' \
        |head -n -1 \
        |tail -n +3 \
        |sed -e :a -e '/^\n*$/{$d;N;ba' -e '}' \
        |cut -c3-)

eval set -- $(getopt \
    -o hi:e:b:msgo: \
    -l help,include:,exclude:,by:,mean,sum,graph,output: \
    -- $@ || echo "$HELP_TEXT" && exit 1;)

while [ $# -gt 0 ];do
    case $1 in
        -h|--help)      echo "$HELP_TEXT" && exit 1;;
        -i|--include)   add_inc_exp "INC" "$2"; shift;;
        -e|--exclude)   add_inc_exp "EXC" "$2"; shift;;
        -b|--by)
            SAVE="$IFS"
            IFS=","
            for i in $2;do
                row $i >/dev/null || exit 1
                add_cat $(row $i)
            done
            shift;
            IFS="$SAVE";;
        -m|--mean)      add_act "mean";;
        -s|--sum)       add_act "sum";;
        -g|--graph)     GRAPH="yes";;
        -o|--output)    OUT="$2"; shift;;
        (--) shift; break;;
        (-*) error "unrecognized option $1";;
        (*)  break;;
    esac
    shift
done

# Functions
inc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat == \"$match\") print \$0; }"; }

exc(){
    local cat=$1; local match=$2;
    awk "{ if (\$$cat != \"$match\") print \$0; }"; }

res(){ awk "{ print \$$RES; }"; }

act(){
    case $ACT in
        all)  tr '\n' ','|sed 's/.$//';;
        sum)  awk '{ sum += $1 }
                   END { if(NR == 0) print "NA"; else print sum; }';;
        mean) awk '{ sum += $1 }
                   END { if(NR == 0) print "NA"; else print sum/NR; }';;
    esac; }

post_process(){
    if [ ! -z "$GRAPH" ];then
        if [ $(which feedgnuplot >/dev/null 2>/dev/null) ];then
            error "Graphing requires the feedgnuplot executable."
        elif [ "$ACT" == "all" ];then
            error "Can't graph all results, must use mean or sum."
        elif [ ${#CAT[@]} -ne 1 ];then
            error "Can only graph a single category at a time."
        else
            if [ ! -z "$OUT" ];then OUT=" --hardcopy $OUT "; fi
            feedgnuplot $OUT \
                --title "$TITLE" \
                -ymin 0 \
                --extracmds 'set style fill solid border -1;' \
                --histogram 2 \
                --curvestyleall 'with boxes' \
                --dataid \
                --autolegen
        fi
    else
        if [ ! -z "$OUT" ];then
            echo "# $TITLE">$OUT
            cat >>$OUT
            echo "Wrote output to $OUT"
        else
            column -t
        fi
    fi; }

# Main
for ((i=0; i<${#INC[@]}; i+=2));do
    DATA="$(echo "$DATA"|inc ${INC[i]} ${INC[i+1]})"
done
for ((i=0; i<${#EXC[@]}; i+=2));do
    DATA="$(echo "$DATA"|exc ${EXC[i]} ${EXC[i+1]})"
done

case ${#CAT[@]} in
    0) echo "$DATA";;
    1)
        for i in $(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u);do
            echo "$i $(echo "$DATA"|inc ${CAT[0]} $i|res|act)"
        done;;
    2)
        XS="$(echo "$DATA"|awk "{print \$${CAT[0]}}"|sort -u)"
        YS="$(echo "$DATA"|awk "{print \$${CAT[1]}}"|sort -u)"
        echo "[$(echo "$XS"|wc -l)x$(echo "$YS"|wc -l)] $(echo $YS)"
        for x in $XS;do
            echo -n "$x "
            for y in $YS;do
                echo -n "$(echo "$DATA"|inc ${CAT[0]} $x|inc ${CAT[1]} $y|res|act) "
            done
            echo ""
        done;;
esac|post_process
exit 0;


# The rest of the file should be raw data.
DATA:
